<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>python-geospatial</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="python-geospatial_files/libs/clipboard/clipboard.min.js"></script>
<script src="python-geospatial_files/libs/quarto-html/quarto.js"></script>
<script src="python-geospatial_files/libs/quarto-html/popper.min.js"></script>
<script src="python-geospatial_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="python-geospatial_files/libs/quarto-html/anchor.min.js"></script>
<link href="python-geospatial_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="python-geospatial_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="python-geospatial_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="python-geospatial_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="python-geospatial_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Geospatial Python</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>This lesson is largely based on material from <a href="https://carpentries-incubator.github.io/geospatial-python/index.html">Introduction to Geospatial Raster and Vector Data with Python</a> by The Carpentries, available under a <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> license.</em></p>
<section id="objectives" class="level3">
<h3 class="anchored" data-anchor-id="objectives">Objectives</h3>
<p>This chapter develops basic GIS programming skills for working with open data on climate risk. You will learn about geospatial data types, projections, spatial operations, basic analysis, and visualization.</p>
</section>
<section id="what-is-gis" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="what-is-gis">What is GIS?</h3>
<p><strong>GIS (Geographic Information System)</strong> is software that allows you to interact with geospatial data: capture, store, analyze, and visualize information about locations on the Earth’s surface. These tools are fundamental for understanding spatial patterns, making informed decisions about resources and territory, and communicating geographic information effectively.</p>
<p>In the context of climate risk management, GIS makes it possible to do things such as identify areas vulnerable to flooding, analyze urban temperature patterns, evaluate green infrastructure coverage, and much more. Common tools include desktop applications (ArcGIS, QGIS), spatial databases (PostGIS), processing libraries (GDAL), cloud platforms (Google Earth Engine), and programming languages (R and Python).</p>
<p>There are two main approaches for working with geospatial data:</p>
<ul>
<li><strong>Graphical user interface (GUI)</strong> applications like ArcGIS and QGIS allow you to work with spatial data without learning a programming language. Mapping and visualization are more intuitive and flexible in this environment. However, these tools have important limitations: low reproducibility of analyses, limited scalability for automation, restricted capacity to customize functionality, and complex interfaces with too many buttons that can be overwhelming.</li>
<li>On the other hand, <strong>programming</strong> offers high reproducibility, scalability, and complete automation. It provides total flexibility to customize functionality and facilitates integration with other workflows and data sources. The main disadvantages are the need to learn a programming language, a steeper learning curve at the beginning, and that mapping and visualization are less intuitive initially.</li>
</ul>
<p>In this book, we use <strong>Python</strong> for all of our analyses. Python is widely used with a rich ecosystem of specialized libraries for geospatial analysis. It is flexible, powerful, and relatively easy to learn compared to other languages. It offers complete integration with databases, APIs, web services, and other programming languages. Additionally, it is free, open source, and has an active community that provides abundant documentation, tutorials, and support. Lastly, its high replicability makes it ideal for sharing analyses that can be adapted and scaled in other contexts.</p>
<section id="cloud-native-geospatial" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="cloud-native-geospatial">Cloud-Native Geospatial</h4>
<p><strong>Cloud-native geospatial</strong> tools are designed specifically to work with data stored in the cloud. Unlike traditional tools that require downloading complete datasets, these tools allow you to access and process only the portions of data needed through protocols like HTTP range requests.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>The <strong>cloud</strong> basically means someone else’s computer: servers that your device connects to over the internet. Cloud computing offers power, flexibility, and scalability as needed without requiring you to configure local servers. It provides distributed and reliable infrastructure. However, it has an initial learning curve, costs can accumulate with intensive use, and it requires constant internet connection.</p>
</div></div><p>Examples include Cloud Optimized GeoTIFF (COG) for raster data, which allows efficient streaming of satellite images without downloading complete files. GeoParquet and FlatGeobuf are cloud-optimized vector formats that support fast spatial queries. Platforms like Google Earth Engine, Microsoft Planetary Computer, and AWS Earth Search provide massive catalogs of satellite data with APIs for analysis at scale.</p>
<p>These tools are especially relevant for climate risk analysis, where we need to process large volumes of satellite, climate, and geographic data without the infrastructure to store them locally. The cloud-native tools we will use are not more difficult than traditional tools and offer many advantages. The cloud is simply one of the places where people compute today. As mentioned in <a href="../intro.qmd#guiding-principles">the introduction</a>, this book takes the cloud-native approach as the default.</p>
</section>
</section>
<section id="coordinate-reference-systems-crs" class="level3">
<h3 class="anchored" data-anchor-id="coordinate-reference-systems-crs">Coordinate Reference Systems (CRS)</h3>
<p><a href="https://py.geocompx.org/01-spatial-data#sec-coordinate-reference-systems-intro">Coordinate reference systems</a> define how the spatial elements of data relate to the Earth’s surface. CRS are geographic or projected. <a href="https://py.geocompx.org/01-spatial-data#geographic-coordinate-systems">Geographic systems</a> identify locations using longitude and latitude in decimal degrees on a spherical or ellipsoidal surface. <a href="https://py.geocompx.org/01-spatial-data#sec-projected-coordinate-reference-systems">Projected systems</a> convert the three-dimensional surface of the Earth into Cartesian coordinates (x, y) in meters on an implicitly flat surface.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../public/python-geoespacial/us-crs-versions.jpg" class="img-fluid figure-img"></p>
<figcaption>Examples of different CRS, Opennews.org via <span class="citation" data-cites="carpentries_geospatial_python">[@carpentries_geospatial_python]</span></figcaption>
</figure>
</div>
<p>All projection introduces deformations. Therefore, some properties of the Earth’s surface are distorted: area, direction, distance, and shape. A projection can preserve only one or two of these properties. Projections are named according to the property they preserve: equal-area preserves area, azimuthal preserves direction, equidistant preserves distance, and conformal preserves local shape.</p>
<p>If you imagine that the Earth is an orange, the way you peel it and then flatten the skin is similar to how projections are made.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../public/python-geoespacial/orange-peel-earth.jpg" class="img-fluid figure-img"></p>
<figcaption>Orange metaphor <span class="citation" data-cites="carpentries_geospatial_python">[@carpentries_geospatial_python]</span></figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>When problems arise with spatial analysis, the cause is often CRS-related issues. When troubleshooting, one of the first things you should check is whether there is a CRS problem.</p>
</div>
</div>
</section>
<section id="vector-data" class="level2">
<h2 class="anchored" data-anchor-id="vector-data">Vector data</h2>
<p>The <a href="https://py.geocompx.org/01-spatial-data#sec-vector-data">vector data model</a> represents geographic features with points, lines, and polygons. These geometries have discrete and well-defined boundaries, which means that vector data generally has high precision. Points can represent independent features (like the location of a bus stop) or they can connect to form more complex geometries like lines and polygons.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../public/python-geoespacial/spatial_extent.png" class="img-fluid figure-img"></p>
<figcaption>Vector data <span class="citation" data-cites="carpentries_geospatial_python">[@carpentries_geospatial_python]</span></figcaption>
</figure>
</div>
<p>Vector data is organized into a table of attributes and geometries. The <a href="https://py.geocompx.org/01-spatial-data#sec-geometry-columns">geometry column</a> is essential in a GeoDataFrame: it contains the geometric part of the vector layer and is the basis for all spatial operations. This column can contain point, line, polygon, or multipolygon, and also stores spatial reference information (CRS).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../public/python-geoespacial/pandas_geopandas_relation.png" class="img-fluid figure-img"></p>
<figcaption>GeoDataframe <span class="citation" data-cites="carpentries_geospatial_python">[@carpentries_geospatial_python]</span></figcaption>
</figure>
</div>
<p>Vectors dominate the social sciences because human settlements and processes (like transportation infrastructure) tend to have discrete boundaries.</p>
<section id="python-libraries-for-vector-data" class="level3">
<h3 class="anchored" data-anchor-id="python-libraries-for-vector-data">Python libraries for vector data</h3>
<p><a href="https://geopandas.org/">GeoPandas</a> extends Pandas to work with spatial geometries using <a href="https://shapely.readthedocs.io/">Shapely</a> for geometric operations and <a href="https://fiona.readthedocs.io/">Fiona</a> for file reading/writing. We also use <a href="https://matplotlib.org/">Matplotlib</a> for basic graphics and visualization.</p>
</section>
<section id="vector-file-formats" class="level3">
<h3 class="anchored" data-anchor-id="vector-file-formats">Vector file formats</h3>
<p>For cloud-native workflows, GeoParquet is a columnar format optimized for analytical queries of large vector datasets, and FlatGeobuf provides efficient spatial access through built-in spatial indexing. Both support HTTP range requests, meaning you can query subsets of data without downloading entire files.</p>
<p>You’ll also encounter GeoJSON (.geojson, .json), which is used for web mapping and stores coordinates as text using JavaScript Object Notation. GeoPackage (.gpkg) is a single-file format that works well for local data exchange. ESRI Shapefile (.shp, .dbf, .shx) is a legacy format that requires multiple files and has technical limitations (field name length, attribute types, file size), but you’ll still encounter it in the wild because many organizations haven’t migrated yet.</p>
<p>We load municipal boundaries for Buenos Aires Province from ARBA’s WFS service <span class="citation" data-cites="arba_partidos_pba">[@arba_partidos_pba]</span>. The code below checks for a cached local copy first, then fetches from the WFS service if needed.</p>
<div id="4e58e339" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> owslib.wfs <span class="im">import</span> WebFeatureService</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> io <span class="im">import</span> StringIO, BytesIO</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>partidos_path <span class="op">=</span> <span class="st">"../../public/python-geoespacial/pba_partidos.parquet"</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Load partidos from ARBA GeoServer WFS service</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> os.path.exists(partidos_path):</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    partidos <span class="op">=</span> gpd.read_parquet(partidos_path)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Connect to WFS (Web Feature Service)</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    wfs_url <span class="op">=</span> <span class="st">"https://geo.arba.gov.ar/geoserver/idera/wfs"</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    wfs <span class="op">=</span> WebFeatureService(url<span class="op">=</span>wfs_url, version<span class="op">=</span><span class="st">"2.0.0"</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Request the Departamento layer (partidos)</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    response <span class="op">=</span> wfs.getfeature(</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        typename<span class="op">=</span><span class="st">"idera:Departamento"</span>,</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        srsname<span class="op">=</span><span class="st">"EPSG:5347"</span>,  <span class="co"># Original CRS</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert WFS response to GeoDataFrame</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    partidos <span class="op">=</span> gpd.read_file(BytesIO(response.read()))</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save to cache for future use</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    partidos.to_parquet(partidos_path)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Reproject to working CRS</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>partidos <span class="op">=</span> partidos.to_crs(<span class="st">"EPSG:5348"</span>)  <span class="co"># POSGAR 2007 / Argentina 4</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="reprojections" class="level3">
<h3 class="anchored" data-anchor-id="reprojections">Reprojections</h3>
<p>Transforming data from one coordinate system to another is frequently necessary when working with multiple data sources. All data must be in the same CRS before performing spatial analysis. In the code above, we reprojected the partidos data to EPSG:5348 (POSGAR 2007 / Argentina 4) using GeoPandas’ <code>to_crs()</code> method. This ensures our data is in a projected coordinate system with units in meters, which is appropriate for spatial calculations in the La Plata region.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>When you have datasets in different coordinate systems, choose a projected CRS that covers your study area. For Argentina, POSGAR 2007 divides the country into 7 Gauss-Krueger zones. Use the zone that covers your municipality. If your study area spans multiple zones, choose the zone that covers the majority of your area. You can confirm CRS codes at <a href="https://epsg.io">epsg.io</a>.</p>
</div>
</div>
<div id="ced847be" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>partidos.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">gml_id</th>
<th data-quarto-table-cell-role="th">cca</th>
<th data-quarto-table-cell-role="th">cde</th>
<th data-quarto-table-cell-role="th">fna</th>
<th data-quarto-table-cell-role="th">gna</th>
<th data-quarto-table-cell-role="th">nam</th>
<th data-quarto-table-cell-role="th">sag</th>
<th data-quarto-table-cell-role="th">ara3</th>
<th data-quarto-table-cell-role="th">arl</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Departamento.437</td>
<td>065</td>
<td>06505</td>
<td>Partido de Magdalena</td>
<td>Partido</td>
<td>Magdalena</td>
<td>ARBA</td>
<td>1849.53</td>
<td>1785.29</td>
<td>MULTIPOLYGON (((6435320.257 6134850.321, 64352...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Departamento.434</td>
<td>090</td>
<td>06686</td>
<td>Partido de Rojas</td>
<td>Partido</td>
<td>Rojas</td>
<td>ARBA</td>
<td>2060.72</td>
<td>1978.87</td>
<td>MULTIPOLYGON (((6128472.001 6214278.169, 61285...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>Departamento.436</td>
<td>058</td>
<td>06455</td>
<td>Partido de Las Flores</td>
<td>Partido</td>
<td>Las Flores</td>
<td>ARBA</td>
<td>3341.36</td>
<td>3340.27</td>
<td>MULTIPOLYGON (((6292198.682 5974257.073, 62916...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>Departamento.485</td>
<td>031</td>
<td>06266</td>
<td>Partido de Exaltación de la Cruz</td>
<td>Partido</td>
<td>Exaltación de la Cruz</td>
<td>ARBA</td>
<td>636.36</td>
<td>634.17</td>
<td>MULTIPOLYGON (((6286757.47 6218024.36, 6286781...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>Departamento.435</td>
<td>046</td>
<td>06364</td>
<td>Partido de General Rodríguez</td>
<td>Partido</td>
<td>General Rodríguez</td>
<td>ARBA</td>
<td>365.40</td>
<td>360.14</td>
<td>MULTIPOLYGON (((6327496.29 6167316.466, 632748...</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="1578517f" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>partidos.plot()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="python-geospatial_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="filter-and-manipulate-geometries" class="level3">
<h3 class="anchored" data-anchor-id="filter-and-manipulate-geometries">Filter and manipulate geometries</h3>
<p>The <code>partidos</code> data has several attributes: department code, department name, and geometry. To extract only the data for the Partido de La Plata, we filter for the observation where the “fna” column corresponds to “Partido de La Plata”.</p>
<div id="092233a7" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>la_plata <span class="op">=</span> partidos[partidos[<span class="st">"fna"</span>] <span class="op">==</span> <span class="st">"Partido de La Plata"</span>]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>la_plata.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">gml_id</th>
<th data-quarto-table-cell-role="th">cca</th>
<th data-quarto-table-cell-role="th">cde</th>
<th data-quarto-table-cell-role="th">fna</th>
<th data-quarto-table-cell-role="th">gna</th>
<th data-quarto-table-cell-role="th">nam</th>
<th data-quarto-table-cell-role="th">sag</th>
<th data-quarto-table-cell-role="th">ara3</th>
<th data-quarto-table-cell-role="th">arl</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">11</td>
<td>Departamento.496</td>
<td>055</td>
<td>06441</td>
<td>Partido de La Plata</td>
<td>Partido</td>
<td>La Plata</td>
<td>ARBA</td>
<td>892.63</td>
<td>942.23</td>
<td>MULTIPOLYGON (((6395811.772 6128078.545, 63970...</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>When we map it we see that it includes not only the urban area but also an island that is technically part of the partido.</p>
<div id="156321e8" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>la_plata.plot(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">12</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="python-geospatial_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>When we examine the geometry type, we see that we have a multipolygon. The geometry can be a point, a line, a polygon, or a multipolygon.</p>
<div id="c99998ca" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(la_plata.geometry.iloc[<span class="dv">0</span>].geom_type)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>MultiPolygon</code></pre>
</div>
</div>
<p>We want to remove the island because it does not correspond to our analysis. We extract the larger geometry of the two.</p>
<div id="9909e17b" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the main geometry and keep only the largest polygon</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>la_plata <span class="op">=</span> la_plata.copy()</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>main_geom <span class="op">=</span> la_plata.geometry.iloc[<span class="dv">0</span>]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>la_plata.loc[la_plata.index[<span class="dv">0</span>], <span class="st">"geometry"</span>] <span class="op">=</span> <span class="bu">max</span>(main_geom.geoms, key<span class="op">=</span><span class="kw">lambda</span> p: p.area)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>When we check the geometry again, we see that it is now a simple polygon and only the partido de La Plata appears without the island.</p>
<div id="d2120960" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(la_plata.geometry.iloc[<span class="dv">0</span>].geom_type)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Polygon</code></pre>
</div>
</div>
<div id="67b845bc" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>la_plata.plot(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">12</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="python-geospatial_files/figure-html/cell-10-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The GeoDataFrame class extends the pandas DataFrame, allowing you to treat non-spatial attributes like a table and process them with standard methods. Spatial predicates are geometric relationships between objects: intersection, containment, proximity, etc. These operations are fundamental for analyses like identifying neighborhoods within flood zones or finding critical infrastructure near risk areas. For more details, see <a href="https://py.geocompx.org/01-spatial-data#sec-vector-data">Geocomputation with Python, Chapter 1</a>.</p>
</section>
</section>
<section id="raster-data" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="raster-data">Raster data</h2>
<p>The <a href="https://py.geocompx.org/01-spatial-data#sec-raster-data">raster data model</a> represents the world through a continuous grid of cells of constant size. This model consists of metadata (header) that defines the coordinate system, the origin, and the resolution, plus a matrix of values. The origin is typically the coordinate of the lower-left corner. This representation avoids explicitly storing the coordinates of each cell, making raster processing much more efficient than vector processing.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../public/python-geoespacial/raster_concept.png" class="img-fluid figure-img"></p>
<figcaption>Raster data <span class="citation" data-cites="carpentries_geospatial_python">[@carpentries_geospatial_python]</span></figcaption>
</figure>
</div>
<p>Cell values are numeric, representing continuous variables (elevation, temperature, precipitation) or categorical variables (land cover types, use classes). Rasters usually represent continuous phenomena, although discrete features like soil classes can also be represented in this model. However, the edges of discrete features can become blurry in raster datasets.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong>Continuous data</strong> refer to values that can take any number within a range (including decimals). These values are stored as floats (floating-point numbers) instead of integers, allowing you to represent precise measurements like 15.7 meters or 23.42 meters of elevation. <strong>Categorical data</strong> represents categories by encoding them as integers.</p>
</div></div><p>Rasters dominate many environmental sciences due to dependence on satellite remote sensing data. Examples include satellite images, aerial photographs, digital elevation models, and precipitation maps. In this chapter we use digital elevation models (continuous) and land cover data (categorical).</p>
<section id="python-libraries-for-raster-data" class="level3">
<h3 class="anchored" data-anchor-id="python-libraries-for-raster-data">Python libraries for raster data</h3>
<p><a href="https://rasterio.readthedocs.io/">Rasterio</a> reads and writes georeferenced raster formats. <a href="https://xarray.dev/">Xarray</a> and <a href="https://corteva.github.io/rioxarray/">rioxarray</a> facilitate working with labeled multidimensional arrays, ideal for climate time series. <a href="https://gdal.org/">GDAL/OGR</a> are the fundamental libraries that underlie many tools.</p>
</section>
<section id="raster-file-formats" class="level3">
<h3 class="anchored" data-anchor-id="raster-file-formats">Raster file formats</h3>
<p>GeoTIFF (.tif, .tiff) is the industry standard format for GIS applications and satellite remote sensing. Cloud Optimized GeoTIFF (COG) is an optimized variant that incorporates tiles and previews to support HTTP queries, allowing you to load subsets of the image without transferring the complete file. For cloud-native workflows with multidimensional data, Zarr is a format optimized for cloud storage, ideal for climate time series.</p>
<p>We work with 30m resolution Digital Surface Model data from the Copernicus DEM <span class="citation" data-cites="copernicus_dem_openlandmap">[@copernicus_dem_openlandmap]</span>, accessed via the Element84 Earth Search STAC catalog. We use Cloud Optimized GeoTIFF along with the <code>rioxarray</code> module to import only the necessary data efficiently. Instead of importing all the global data (several terabytes), we import only our area of interest through lazy loading. This means we don’t download the data until we have filtered it, thus using only the essential memory and computational power.</p>
<div id="8e7a4bd6" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pystac_client</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> odc.stac <span class="im">import</span> load</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rioxarray <span class="im">as</span> rio</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Reproject to geographic CRS for bounding box query</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>aoi <span class="op">=</span> la_plata.to_crs(<span class="st">"EPSG:4326"</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Configure AWS for unsigned requests (no login required)</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>os.environ[<span class="st">"AWS_NO_SIGN_REQUEST"</span>] <span class="op">=</span> <span class="st">"YES"</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>os.environ[<span class="st">"GDAL_DISABLE_READDIR_ON_OPEN"</span>] <span class="op">=</span> <span class="st">"EMPTY_DIR"</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Connect to Element84 Earth Search STAC catalog</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>catalog <span class="op">=</span> pystac_client.Client.<span class="bu">open</span>(<span class="st">"https://earth-search.aws.element84.com/v1"</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Get bounding box for our area of interest</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co"># bbox format: [min_x, min_y, max_x, max_y]</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>bbox <span class="op">=</span> aoi.total_bounds</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Search for Copernicus DEM tiles covering our area</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="co"># cop-dem-glo-30 is the global 30m elevation dataset</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>search <span class="op">=</span> catalog.search(</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    collections<span class="op">=</span>[<span class="st">"cop-dem-glo-30"</span>],</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    bbox<span class="op">=</span>bbox,</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the items (files) that cover our area</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>items <span class="op">=</span> <span class="bu">list</span>(search.items())</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Load DSM using chunks for efficient memory processing</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a><span class="co"># odc.stac.load automatically downloads and assembles the necessary tiles</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>dsm <span class="op">=</span> load(</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>    items,</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>    bbox<span class="op">=</span>bbox,</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    chunks<span class="op">=</span>{<span class="st">"x"</span>: <span class="dv">1024</span>, <span class="st">"y"</span>: <span class="dv">1024</span>},  <span class="co"># Process in blocks for efficiency</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract elevation band and convert to DataArray for use with rioxarray</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a><span class="co"># load() returns a Dataset; we need the elevation DataArray</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>dsm <span class="op">=</span> dsm[<span class="st">"data"</span>].squeeze()  <span class="co"># Remove extra dimensions</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Clip raster to exact geometries</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>dsm_clipped <span class="op">=</span> dsm.rio.clip(aoi.geometry)</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Reproject clipped area to working CRS (POSGAR 2007 / Argentina 4)</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a><span class="co"># This is more efficient because we reproject only the area of interest</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>dsm_reproj <span class="op">=</span> dsm_clipped.rio.reproject(dst_crs<span class="op">=</span><span class="st">"EPSG:5348"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We visualize the digital surface model for La Plata. The <code>robust=True</code> parameter improves contrast by ignoring extreme values, and <code>cmap="terrain"</code> uses an appropriate color palette for elevation.</p>
<div id="2c0d83d3" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>dsm_reproj.plot(robust<span class="op">=</span><span class="va">True</span>, cmap<span class="op">=</span><span class="st">"terrain"</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">12</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="python-geospatial_files/figure-html/cell-12-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="zonal-statistics-connecting-raster-and-vector" class="level3">
<h3 class="anchored" data-anchor-id="zonal-statistics-connecting-raster-and-vector">Zonal statistics: connecting raster and vector</h3>
<p>Zonal statistics allow you to calculate aggregate values from a raster within zones defined by vector polygons. This operation is fundamental for connecting continuous data (raster) with administrative units (vector). We extract elevation statistics for the La Plata area.</p>
<div id="3628cfac" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> rasterstats <span class="im">import</span> zonal_stats</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>la_plata <span class="op">=</span> la_plata.copy()</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract elevation statistics (min, mean, median, max)</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>stats <span class="op">=</span> zonal_stats(</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    la_plata,</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    dsm_reproj.squeeze().values,</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    affine<span class="op">=</span>dsm_reproj.rio.transform(),</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    stats<span class="op">=</span>[<span class="st">"min"</span>, <span class="st">"mean"</span>, <span class="st">"median"</span>, <span class="st">"max"</span>],</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    nodata<span class="op">=</span>np.nan,</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Add the statistics as new columns</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>la_plata[<span class="st">"dsm_min"</span>] <span class="op">=</span> [s[<span class="st">"min"</span>] <span class="cf">for</span> s <span class="kw">in</span> stats]</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>la_plata[<span class="st">"dsm_mean"</span>] <span class="op">=</span> [s[<span class="st">"mean"</span>] <span class="cf">for</span> s <span class="kw">in</span> stats]</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>la_plata[<span class="st">"dsm_median"</span>] <span class="op">=</span> [s[<span class="st">"median"</span>] <span class="cf">for</span> s <span class="kw">in</span> stats]</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>la_plata[<span class="st">"dsm_max"</span>] <span class="op">=</span> [s[<span class="st">"max"</span>] <span class="cf">for</span> s <span class="kw">in</span> stats]</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>la_plata[</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    [</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        <span class="st">"fna"</span>,</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>        <span class="st">"dsm_min"</span>,</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>        <span class="st">"dsm_mean"</span>,</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>        <span class="st">"dsm_median"</span>,</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>        <span class="st">"dsm_max"</span>,</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">fna</th>
<th data-quarto-table-cell-role="th">dsm_min</th>
<th data-quarto-table-cell-role="th">dsm_mean</th>
<th data-quarto-table-cell-role="th">dsm_median</th>
<th data-quarto-table-cell-role="th">dsm_max</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">11</td>
<td>Partido de La Plata</td>
<td>-4.320292</td>
<td>19.391156</td>
<td>20.339926</td>
<td>52.470333</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>We import 30m resolution categorical land cover data from MapBiomas Argentina Collection 1 <span class="citation" data-cites="mapbiomas_argentina_2022">[@mapbiomas_argentina_2022]</span>, covering 1998-2022. This is the most reliable land cover data currently available for Argentina. The dataset is accessed directly from MapBiomas’ public Google Cloud Storage bucket without requiring a local copy, since we clip to our area of interest before downloading.</p>
<div id="d2dcf34d" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>suelo_2022_ruta <span class="op">=</span> <span class="st">"https://storage.googleapis.com/mapbiomas-public/initiatives/argentina/collection-1/coverage/argentina_coverage_2022.tif"</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Open the raster with rioxarray and chunks</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>suelo_2022 <span class="op">=</span> rio.open_rasterio(</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    suelo_2022_ruta,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    chunks<span class="op">=</span>{<span class="st">"x"</span>: <span class="dv">4096</span>, <span class="st">"y"</span>: <span class="dv">4096</span>},</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Clip in the raster's native CRS (EPSG:4326)</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>suelo_2022_clipped <span class="op">=</span> suelo_2022.rio.clip(</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    aoi.geometry.values,</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    from_disk<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Reproject to working CRS (POSGAR 2007 / Argentina 4)</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>suelo_2022 <span class="op">=</span> suelo_2022_clipped.rio.reproject(dst_crs<span class="op">=</span><span class="st">"EPSG:5348"</span>)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Mask NoData values</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>suelo_2022_masked <span class="op">=</span> suelo_2022.where(</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    (suelo_2022 <span class="op">!=</span> suelo_2022.rio.nodata) <span class="op">&amp;</span> (suelo_2022 <span class="op">!=</span> <span class="dv">255</span>)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="spatial-clipping" class="level3">
<h3 class="anchored" data-anchor-id="spatial-clipping">Spatial clipping</h3>
<p>Extracting data within a specific area of interest is one of the most common spatial operations. In the code above, we clipped the national land cover data to the boundaries of La Plata using the <code>.rio.clip()</code> method. This operation reduces the dataset from the entire country to just our study area, making subsequent processing faster and more focused. Note that we clip in the raster’s native CRS (EPSG:4326) before reprojecting to our working CRS (EPSG:5348).</p>
<div id="be1c6bbc" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Show legend and formatting code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.colors <span class="im">as</span> mcolors</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Define land cover categories with their IDs and MapBiomas colors</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>categories <span class="op">=</span> {</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Closed woody"</span>: {<span class="st">"ids"</span>: [<span class="dv">3</span>], <span class="st">"color"</span>: <span class="st">"#1f8d49"</span>},</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Open woody"</span>: {<span class="st">"ids"</span>: [<span class="dv">4</span>], <span class="st">"color"</span>: <span class="st">"#7dc975"</span>},</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Sparse woody"</span>: {<span class="st">"ids"</span>: [<span class="dv">45</span>], <span class="st">"color"</span>: <span class="st">"#807a40"</span>},</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Flooded woody"</span>: {<span class="st">"ids"</span>: [<span class="dv">6</span>], <span class="st">"color"</span>: <span class="st">"#026975"</span>},</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Flooded non-woody vegetation"</span>: {<span class="st">"ids"</span>: [<span class="dv">11</span>], <span class="st">"color"</span>: <span class="st">"#519799"</span>},</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Grassland"</span>: {<span class="st">"ids"</span>: [<span class="dv">12</span>], <span class="st">"color"</span>: <span class="st">"#d6bc74"</span>},</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Steppe"</span>: {<span class="st">"ids"</span>: [<span class="dv">63</span>], <span class="st">"color"</span>: <span class="st">"#ebf8b5"</span>},</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Pasture"</span>: {<span class="st">"ids"</span>: [<span class="dv">15</span>], <span class="st">"color"</span>: <span class="st">"#edde8e"</span>},</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Agriculture"</span>: {<span class="st">"ids"</span>: [<span class="dv">18</span>], <span class="st">"color"</span>: <span class="st">"#e974ed"</span>},</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Forest plantation"</span>: {<span class="st">"ids"</span>: [<span class="dv">9</span>], <span class="st">"color"</span>: <span class="st">"#7a5900"</span>},</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Shrub crop"</span>: {<span class="st">"ids"</span>: [<span class="dv">36</span>], <span class="st">"color"</span>: <span class="st">"#d082de"</span>},</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Agricultural mosaic"</span>: {<span class="st">"ids"</span>: [<span class="dv">21</span>], <span class="st">"color"</span>: <span class="st">"#ffefc3"</span>},</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Non-vegetated area"</span>: {<span class="st">"ids"</span>: [<span class="dv">22</span>], <span class="st">"color"</span>: <span class="st">"#d4271e"</span>},</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">"River, lake or ocean"</span>: {<span class="st">"ids"</span>: [<span class="dv">33</span>], <span class="st">"color"</span>: <span class="st">"#2532e4"</span>},</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Ice and surface snow"</span>: {<span class="st">"ids"</span>: [<span class="dv">34</span>], <span class="st">"color"</span>: <span class="st">"#93dfe6"</span>},</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Not observed"</span>: {<span class="st">"ids"</span>: [<span class="dv">27</span>], <span class="st">"color"</span>: <span class="st">"#ffffff"</span>},</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the unique IDs present in the data</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>unique_values <span class="op">=</span> np.unique(</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    suelo_2022_masked.values[<span class="op">~</span>np.isnan(suelo_2022_masked.values)]</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>).astype(<span class="bu">int</span>)</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>present_ids <span class="op">=</span> <span class="bu">set</span>(unique_values)</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter only the categories that appear in our data</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>present_categories <span class="op">=</span> {</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    name: info</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name, info <span class="kw">in</span> categories.items()</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">any</span>(<span class="bu">id</span> <span class="kw">in</span> present_ids <span class="cf">for</span> <span class="bu">id</span> <span class="kw">in</span> info[<span class="st">"ids"</span>])</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Create color map</span></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>colors_by_id <span class="op">=</span> {}</span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> info <span class="kw">in</span> categories.values():</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> pixel_id <span class="kw">in</span> info[<span class="st">"ids"</span>]:</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>        colors_by_id[pixel_id] <span class="op">=</span> info[<span class="st">"color"</span>]</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>sorted_ids <span class="op">=</span> <span class="bu">sorted</span>(colors_by_id.keys())</span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>cmap <span class="op">=</span> mcolors.ListedColormap([colors_by_id[i] <span class="cf">for</span> i <span class="kw">in</span> sorted_ids])</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>norm <span class="op">=</span> mcolors.BoundaryNorm(sorted_ids, cmap.N)</span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the land cover raster</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">20</span>))</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>suelo_2022_masked.plot(ax<span class="op">=</span>ax, cmap<span class="op">=</span>cmap, norm<span class="op">=</span>norm, add_colorbar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a><span class="co"># Create legend only with the present categories</span></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>legend <span class="op">=</span> [</span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>    plt.Rectangle((<span class="dv">0</span>, <span class="dv">0</span>), <span class="dv">1</span>, <span class="dv">1</span>, facecolor<span class="op">=</span>info[<span class="st">"color"</span>], label<span class="op">=</span>name)</span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name, info <span class="kw">in</span> present_categories.items()</span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>ax.legend(</span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>    handles<span class="op">=</span>legend,</span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>    loc<span class="op">=</span><span class="st">"lower center"</span>,</span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a>    bbox_to_anchor<span class="op">=</span>(<span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.1</span>),</span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>    ncol<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>    frameon<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Land Cover - MapBiomas 2022"</span>)</span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="python-geospatial_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="analyze-territorial-distribution" class="level3">
<h3 class="anchored" data-anchor-id="analyze-territorial-distribution">Analyze territorial distribution</h3>
<p>To better understand the composition of the territory, we calculate what percentage of the La Plata area corresponds to each type of land cover.</p>
<div id="f54b3155" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract raster values and remove NoData</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> suelo_2022_masked.values.flatten()</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> values[<span class="op">~</span>np.isnan(values)]</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Count pixels of each unique ID</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>unique_ids, counts <span class="op">=</span> np.unique(values, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Group IDs by coverage category</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>counts_by_category <span class="op">=</span> {}</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, info <span class="kw">in</span> categories.items():</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="bu">sum</span>(</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        counts[unique_ids <span class="op">==</span> pixel_id][<span class="dv">0</span>] <span class="cf">if</span> pixel_id <span class="kw">in</span> unique_ids <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pixel_id <span class="kw">in</span> info[<span class="st">"ids"</span>]</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> total <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        counts_by_category[name] <span class="op">=</span> {<span class="st">"count"</span>: total, <span class="st">"color"</span>: info[<span class="st">"color"</span>]}</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate percentages</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>total_pixels <span class="op">=</span> <span class="bu">sum</span>(cat[<span class="st">"count"</span>] <span class="cf">for</span> cat <span class="kw">in</span> counts_by_category.values())</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name <span class="kw">in</span> counts_by_category:</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    percentage <span class="op">=</span> (counts_by_category[name][<span class="st">"count"</span>] <span class="op">/</span> total_pixels) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    counts_by_category[name][<span class="st">"percentage"</span>] <span class="op">=</span> percentage</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort from highest to lowest percentage</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>sorted_categories <span class="op">=</span> <span class="bu">sorted</span>(</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    counts_by_category.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">"percentage"</span>], reverse<span class="op">=</span><span class="va">True</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ba640307" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Show chart formatting code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create horizontal bar chart</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>names <span class="op">=</span> [cat[<span class="dv">0</span>] <span class="cf">for</span> cat <span class="kw">in</span> sorted_categories]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>percentages <span class="op">=</span> [cat[<span class="dv">1</span>][<span class="st">"percentage"</span>] <span class="cf">for</span> cat <span class="kw">in</span> sorted_categories]</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [cat[<span class="dv">1</span>][<span class="st">"color"</span>] <span class="cf">for</span> cat <span class="kw">in</span> sorted_categories]</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>bars <span class="op">=</span> ax.barh(names, percentages, color<span class="op">=</span>colors, edgecolor<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Percentage (%)"</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Cover Type"</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>ax.set_title(</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Land Cover Distribution - La Plata (MapBiomas 2022)"</span>,</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    fontsize<span class="op">=</span><span class="dv">14</span>,</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    fontweight<span class="op">=</span><span class="st">"bold"</span>,</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>ax.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, axis<span class="op">=</span><span class="st">"x"</span>)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Add percentage labels on the bars</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> bar, pct <span class="kw">in</span> <span class="bu">zip</span>(bars, percentages):</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    ax.text(</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>        pct <span class="op">+</span> <span class="fl">0.5</span>,</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>        bar.get_y() <span class="op">+</span> bar.get_height() <span class="op">/</span> <span class="dv">2</span>,</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"</span><span class="sc">{</span>pct<span class="sc">:.1f}</span><span class="ss">%"</span>,</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>        va<span class="op">=</span><span class="st">"center"</span>,</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>        fontsize<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="python-geospatial_files/figure-html/cell-17-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="spatial-aggregation" class="level3">
<h3 class="anchored" data-anchor-id="spatial-aggregation">Spatial aggregation</h3>
<p>Spatial aggregation combines multiple geometries or calculates summary statistics within geographic areas. We demonstrate this by counting building footprints within La Plata using cloud-native building data from the Google-Microsoft-OSM Open Buildings dataset <span class="citation" data-cites="google_microsoft_osm_buildings">[@google_microsoft_osm_buildings]</span>.</p>
<div id="c5933c1a" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> duckdb</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Get bounding box of La Plata in WGS84 (EPSG:4326) for cloud query</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>bounds_4326 <span class="op">=</span> la_plata.to_crs(<span class="st">"EPSG:4326"</span>).total_bounds</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Configure DuckDB with spatial and network extensions</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>con <span class="op">=</span> duckdb.<span class="ex">connect</span>()</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>con.execute(<span class="st">"INSTALL spatial"</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>con.execute(<span class="st">"LOAD spatial"</span>)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>con.execute(<span class="st">"INSTALL httpfs"</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>con.execute(<span class="st">"LOAD httpfs"</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Configure DuckDB for S3 cloud storage access</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>con.execute(<span class="st">"SET s3_region='us-east-1'"</span>)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>con.execute(<span class="st">"SET s3_endpoint='data.source.coop'"</span>)</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>con.execute(<span class="st">"SET s3_use_ssl=true"</span>)</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>con.execute(<span class="st">"SET s3_url_style='path'"</span>)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Query buildings within our bounding box and save to temporary file</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="co"># This filters buildings using geographic bounds (bbox) to load only those in our area of interest</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>temp_file <span class="op">=</span> <span class="st">"buildings_filtered.parquet"</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>query <span class="op">=</span> <span class="ss">f"""</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="ss">COPY (</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="ss">    SELECT *</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="ss">    FROM 's3://vida/google-microsoft-open-buildings/geoparquet/by_country/country_iso=ARG/ARG.parquet'</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a><span class="ss">    WHERE bbox.xmax &gt;= </span><span class="sc">{</span>bounds_4326[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> AND bbox.xmin &lt;= </span><span class="sc">{</span>bounds_4326[<span class="dv">2</span>]<span class="sc">}</span><span class="ss"> AND</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a><span class="ss">          bbox.ymax &gt;= </span><span class="sc">{</span>bounds_4326[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> AND bbox.ymin &lt;= </span><span class="sc">{</span>bounds_4326[<span class="dv">3</span>]<span class="sc">}</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="ss">) TO '</span><span class="sc">{</span>temp_file<span class="sc">}</span><span class="ss">' (FORMAT PARQUET);</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a><span class="ss">"""</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>con.execute(query)</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Read filtered building data from Parquet file</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>buildings_df <span class="op">=</span> pd.read_parquet(temp_file)</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Deserialize geometries: convert from binary format (WKB - Well-Known Binary) to GeoSeries objects</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a><span class="co"># GeoParquet stores geometries as bytes in WKB format, we need to convert them to GeoPandas geometries</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>buildings_df[<span class="st">"geometry"</span>] <span class="op">=</span> gpd.GeoSeries.from_wkb(buildings_df[<span class="st">"geometry"</span>])</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Create GeoDataFrame with deserialized geometries</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify original CRS as EPSG:4326 (WGS84) since data comes in that coordinate system</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>buildings <span class="op">=</span> gpd.GeoDataFrame(buildings_df, geometry<span class="op">=</span><span class="st">"geometry"</span>, crs<span class="op">=</span><span class="st">"EPSG:4326"</span>)</span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Reproject to working CRS to match other analysis data</span></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>buildings <span class="op">=</span> buildings.to_crs(<span class="st">"EPSG:5348"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"5951509c14ab40cd80b34d94b6e08a42","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<p>Now we spatially filter buildings that fall within La Plata’s boundaries and count them:</p>
<div id="2388e467" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Spatial join: keep only buildings that intersect with La Plata polygon</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>buildings_in_la_plata <span class="op">=</span> gpd.sjoin(buildings, la_plata, predicate<span class="op">=</span><span class="st">"intersects"</span>, how<span class="op">=</span><span class="st">"inner"</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Count total buildings</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>total_buildings <span class="op">=</span> <span class="bu">len</span>(buildings_in_la_plata)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total buildings in La Plata: </span><span class="sc">{</span>total_buildings<span class="sc">:,}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total buildings in La Plata: 625,936</code></pre>
</div>
</div>
<div id="fda62491" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Show map visualization code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize buildings within La Plata</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">12</span>))</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot La Plata boundary</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>la_plata.plot(ax<span class="op">=</span>ax, facecolor<span class="op">=</span><span class="st">"none"</span>, edgecolor<span class="op">=</span><span class="st">"black"</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot buildings with orange outlines</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>buildings_in_la_plata.plot(ax<span class="op">=</span>ax, facecolor<span class="op">=</span><span class="st">"none"</span>, edgecolor<span class="op">=</span><span class="st">"orange"</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="ss">f"Building Footprints in La Plata</span><span class="ch">\n</span><span class="ss">Total buildings: </span><span class="sc">{</span>total_buildings<span class="sc">:,}</span><span class="ss">"</span>,</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>             fontsize<span class="op">=</span><span class="dv">14</span>, fontweight<span class="op">=</span><span class="st">"bold"</span>)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="python-geospatial_files/figure-html/cell-20-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="other-common-spatial-operations" class="level2">
<h2 class="anchored" data-anchor-id="other-common-spatial-operations">Other Common Spatial Operations</h2>
<p>Throughout this chapter, we’ve demonstrated several fundamental spatial operations: reprojections (converting between coordinate systems), spatial clipping (extracting data for a specific area), zonal statistics (summarizing raster values within vector polygons), and spatial aggregation (combining geometries by attributes). These operations form the core of most climate risk workflows.</p>
<p>Other common spatial operations you’ll encounter in geospatial analysis include spatial overlays (combining multiple data layers based on spatial relationships) and buffers (creating zones around features for proximity analysis). These operations are covered in detail in the resources below and will appear in later chapters when we apply them to specific climate risk problems.</p>
</section>
<section id="additional-resources" class="level2">
<h2 class="anchored" data-anchor-id="additional-resources">Additional Resources</h2>
<p>To deepen your knowledge of geospatial analysis with Python, consult these complete and free resources:</p>
<p>Rey, S., Arribas-Bel, D., &amp; Wolf, L. (2023). <a href="https://geographicdata.science/book/intro.html">Geographic Data Science with Python</a>. CRC Press.</p>
<p>Dorman, M., Graser, A., Nowosad, J., &amp; Lovelace, R. (2025). <a href="https://py.geocompx.org/">Geocomputation with Python</a>. CRC Press.</p>
<p>To explore traditional GIS software and commercial platforms, visit <a href="https://carpentries-incubator.github.io/geospatial-python/index.html">The Carpentries Geospatial Python workshop</a> which includes detailed information about open source options (QGIS, GRASS GIS, GDAL) and commercial solutions (ArcGIS, MapInfo).</p>
</section>

</main>
<!-- /main column -->
<script type="application/vnd.jupyter.widget-state+json">
{"state":{"2f47a0cff92b4e3a98a872cea288326d":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"ProgressStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"ProgressStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","bar_color":"black","description_width":""}},"5951509c14ab40cd80b34d94b6e08a42":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"FloatProgressModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"FloatProgressModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"ProgressView","bar_style":"","description":"","description_allow_html":false,"layout":"IPY_MODEL_971acf6966ab4e94962744e411ff7020","max":100,"min":0,"orientation":"horizontal","style":"IPY_MODEL_2f47a0cff92b4e3a98a872cea288326d","tabbable":null,"tooltip":null,"value":100}},"971acf6966ab4e94962744e411ff7020":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":"auto"}}},"version_major":2,"version_minor":0}
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>